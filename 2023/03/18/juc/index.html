<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JUC笔记 | 云卷云舒</title><meta name="keywords" content="JUC,java"><meta name="author" content="云卷云舒"><meta name="copyright" content="云卷云舒"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="JUC相关教程">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC笔记">
<meta property="og:url" content="https://ynu.icu/2023/03/18/juc/index.html">
<meta property="og:site_name" content="云卷云舒">
<meta property="og:description" content="JUC相关教程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ynu.icu/img/img.png">
<meta property="article:published_time" content="2023-03-18T11:18:23.402Z">
<meta property="article:modified_time" content="2023-03-18T11:22:24.302Z">
<meta property="article:author" content="云卷云舒">
<meta property="article:tag" content="java">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ynu.icu/img/img.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ynu.icu/2023/03/18/juc/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=ZCOOL KuaiLe" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JUC笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-18 19:22:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/img.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">云卷云舒</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-18T11:18:23.402Z" title="发表于 2023-03-18 19:18:23">2023-03-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-18T11:22:24.302Z" title="更新于 2023-03-18 19:22:24">2023-03-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1.前置知识"></a>1.前置知识</h1><h2 id="1-1-Synchronized"><a href="#1-1-Synchronized" class="headerlink" title="1.1 Synchronized"></a>1.1 Synchronized</h2><p>synchronized 是 Java 中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>
<p>\1. 修饰一个<strong>代码块</strong>，被修饰的代码块称为同步语句块，其作用的范围是大括号{} 括起来的代码，作用的对象是调用这个代码块的对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (monitor)&#123;</span><br><span class="line"> 操作   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中monitor同步监视器俗称锁,锁可以是任意对象(包括class对象),但是要求 <strong>多个线程必须使用同一把锁</strong></p>
<p>\2. 修饰一个<strong>方法</strong>，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</p>
<ul>
<li>​    修饰方法方法时不需要显示地指定同步监视器,默认情况下:<ul>
<li>如果是静态方法,同步监视器为定义方法的这个类</li>
<li>如果是实例方法,同步监视器为对象</li>
</ul>
</li>
<li>虽然可以使用 synchronized 来定义方法，但synchronized 并不属于方法定义的一部分，因此，synchronized 关键字不能被继承。<ul>
<li>如果在父类中的某个方法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方</li>
</ul>
</li>
</ul>
<p>​                法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此， 子类的方法也就相当于同步了。</p>
<h3 id="1-1-2-wait与notify"><a href="#1-1-2-wait与notify" class="headerlink" title="1.1.2 wait与notify()"></a>1.1.2 wait与notify()</h3><p>wait()会使当前线程等待,同时会释放锁,当其他线程调用 notify()时,线程会重新获得锁并继续执行。</p>
<p>notify():唤醒一个睡眠的线程,如果有多个线程睡眠,就唤醒优先级最高的(或随机唤醒)</p>
<p>notifyAll():唤醒全部睡眠的线程</p>
<p>注意:<br>*1.wait()，notify( )，notifyAll()三个方法必须使用在同步代码块或同步方法中。<br>*2.wait()，notify()， notifyAlL()三个方法的调用者必须是同步代码块或同步方法中的同步监视器中<br>否则，会出现ILLegaLMonitorstateException异常<br>*3.wait( ), notify( )， notifyALl()三个方法是定义在java.Lang.object类中。</p>
<p>*面试题: sleep()和wait(()的异同?</p>
<ul>
<li>1.相同点:一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>*2.不同点:1）两个方法声明的位置不同:Thread类中声明sLeep() , object类中声明wait()i<br>2）调用的要求不同: sleep()可以在任何需要的场景下调用。wait()必须使用在同步代码块或同步方法中,由对应的同步监视器调用<br>3）关于是否释放同步监视器:,如果两个方法都使用在同步代码块或同步方法中，sLeep()不会释放,wait()会释放</li>
</ul>
<p><strong>如果synchronized修饰方法,可以不写this.wait()而是直接写wait()</strong></p>
<h3 id="1-1-3虚假唤醒"><a href="#1-1-3虚假唤醒" class="headerlink" title="1.1.3虚假唤醒"></a>1.1.3虚假唤醒</h3><p>有多个线程执行了wait()方法，需要其他线程执行notify()或者notifyAll()方法去唤醒它们，假如多个线程都被唤醒了，但是只有其中一部分是有用的唤醒操作，其余的唤醒都是无用功；对于不应该被唤醒的线程而言，便是虚假唤醒。</p>
<p>• if会出现虚假唤醒的原因:从wait()中被唤醒的进程会继续执行后面的语句,从而跳过if判断</p>
<p>• 解决虚假唤醒:使用while循环去循环判断一个条件，而不是使用if只判断一次条件；即wait()要在while循环中。</p>
<h2 id="1-2-lock和synchronized"><a href="#1-2-lock和synchronized" class="headerlink" title="1.2 lock和synchronized"></a>1.2 lock和synchronized</h2><p><img src="https://img-blog.csdn.net/20180904143958577?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlZmVuZ2xpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ol>
<li>异常是否释放锁：<br> synchronized在发生异常时候会自动释放占有的锁，因此不会出现<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%AD%BB%E9%94%81&spm=1001.2101.3001.7020">死锁</a>；而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）</li>
<li>是否响应中断<br> lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；</li>
<li>是否知道获取锁<br> Lock可以通过trylock来知道有没有获取锁，而synchronized不能；</li>
<li>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</li>
<li>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</li>
</ol>
<p>总结:synchronized简单,自动,lock更加灵活(公平,try),性能更好</p>
<h1 id="2-线程间通信-生产者消费者"><a href="#2-线程间通信-生产者消费者" class="headerlink" title="2.线程间通信(生产者消费者)"></a>2.线程间通信(生产者消费者)</h1><p>在多生产者消费者的场景下,生产者使用sychronized的notifyAll不但会唤醒全部消费者,还会唤醒其它生产者,故应当使用lock:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//num&gt;0时,才能进行消费,否则睡眠</span></span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            num--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::目前剩余&quot;</span> + num + <span class="string">&quot;件产品&quot;</span>);</span><br><span class="line">            <span class="comment">//消费完成后唤醒一个生产者</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//num&lt;20,才能进行生产,否则睡眠</span></span><br><span class="line">            <span class="keyword">while</span> (num &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep((<span class="type">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::目前剩余&quot;</span> + num + <span class="string">&quot;件产品&quot;</span>);</span><br><span class="line">            <span class="comment">//生产完成后唤醒一个消费者</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantLock <span class="title function_">getLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明:lock默认为非公平,这就会导致某一个线程每次调度都能抢到cpu直到自身被阻塞</p>
<p>需要配置fair为true:</p>
<p><img src="C:\Users\xzwnp\AppData\Roaming\marktext\images\2022-07-21-15-53-02-image.png"></p>
<h1 id="3-集合类不安全"><a href="#3-集合类不安全" class="headerlink" title="3.集合类不安全"></a>3.集合类不安全</h1><h2 id="3-1引入"><a href="#3-1引入" class="headerlink" title="3.1引入"></a>3.1引入</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>使用List进行迭代时,如果修改了list,调用迭代器的next()会报错</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013168615/article/details/116570591">https://blog.csdn.net/u013168615/article/details/116570591</a></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h3><ul>
<li><p>每次创建迭代器的时候会初始化一个名expectedModCount的变量,值为modCount(修改次数)</p>
<p>int expectedModCount &#x3D; modCount;</p>
</li>
<li><p>每次修改list时modCount+1</p>
</li>
<li><p>next()方法会先调用checkForComodification(),通过判断expectedModCount &#x3D;&#x3D;modCount 来判断list是否被修改</p>
</li>
<li><p>如果list被修改了,就会抛异常ConcurrentModificationException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(integer==<span class="number">2</span>)</span><br><span class="line">                list.remove(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上面这段代码,第一次next()后修改了list,导致第二次调用next时,expectedModCount !&#x3D;modCount,抛出异常</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>如果是单线程,使用迭代器给出的add&#x2F;remove方法来修改即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">       checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    AbstractList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; cursor)</span><br><span class="line">        cursor--;</span><br><span class="line">    lastRet = -<span class="number">1</span>;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中，删除元素实际上调用的就是list.remove()方法，但是它多了一个操作：<br>expectedModCount &#x3D; modCount;</p>
<p>如果是多线程:</p>
<p>    1.使用Vector</p>
<ul>
<li>Vector的增删改都加上了synchronized关键字,toString&#x2F;iterator方法也是</li>
</ul>
<p>    2.使用Collections.synchronizedList()获取一个线程安全的List,其原理同(1)</p>
<p>     3.使用CopyOnWriteArrayList</p>
<p> <strong>使用CopyOnWriteArrayList的好处在于</strong>,进行写操作的同时其他线程可以正常进行读操作</p>
<p>    Vector的get方法加锁了,但cow没有</p>
<h2 id="3-2ConcurrentHashMap"><a href="#3-2ConcurrentHashMap" class="headerlink" title="3.2ConcurrentHashMap"></a>3.2ConcurrentHashMap</h2><p><strong>为什么ConcurrentHashMap是线程安全的?</strong></p>
<p>JDK1.7中，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ConcurrentHashMap&spm=1001.2101.3001.7020">ConcurrentHashMap</a>使用的锁分段技术，将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>JDK1.8放弃了锁分段的做法，采用<code>CAS</code>和<code>synchronized</code>方式处理并发。</p>
<p><strong>以put操作为例:</strong></p>
<p>1.计算hash值,然后通过hash取模定位到数组中的一个Node元素</p>
<p>2.如果Node为null,CAS设置Node</p>
<p>3.如果Node的hash值为-1,说明其他线程正在扩容,参与扩容</p>
<p>4.否则,加锁,到链表或红黑树设置值</p>
<p><strong>HashTable也是线程安全的，为什么不推荐使用HashTable呢</strong><br>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为多个线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<blockquote>
<p>ConcurrentHashMap的并发度如何?</p>
<p>1.7中 取决于Segment的长度大小</p>
<p>1.8中,由于是对整个Node元素加锁,取决于Node数组的大小</p>
</blockquote>
<h1 id="4-公平锁和非公平锁"><a href="#4-公平锁和非公平锁" class="headerlink" title="4.公平锁和非公平锁"></a>4.公平锁和非公平锁</h1><p>公平锁―是指多个线程按照<strong>申请锁的顺序</strong>来获取锁，类似排队打饭，先来后到。<br>非公平锁是指多个线程<strong>获取锁的顺序</strong>并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁</p>
<p>区别</p>
<p>1.非公平锁不需要进行申请，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。<br>2.非公平锁的优点在于吞吐量比公平锁大(毕竟少了申请这一步骤。<br>3.Synchronized也是一种非公平锁</p>
<h1 id="5-callable创建线程"><a href="#5-callable创建线程" class="headerlink" title="5.callable创建线程"></a>5.callable创建线程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建callable对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"><span class="comment">//        2.创建futureTask对象,其泛型为callable接口中call方法的返回值</span></span><br><span class="line">        <span class="comment">//FutureTask类实现了Runnable接口,可以查看Callable接口的返回值</span></span><br><span class="line">        <span class="comment">//注意,一个futureTask只能对应一个线程</span></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myThread);</span><br><span class="line">        FutureTask&lt;String&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myThread);</span><br><span class="line">        <span class="comment">//3.创建线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">        <span class="comment">//4.获取结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//futureTask.get会被阻塞,直到call()方法返回</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">//        1.创建Callable接口实现类</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行中...&quot;</span>);</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;运行完毕...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-JUC三大辅助类"><a href="#6-JUC三大辅助类" class="headerlink" title="6.JUC三大辅助类"></a>6.JUC三大辅助类</h1><h2 id="CountDownLatch-减少计数"><a href="#CountDownLatch-减少计数" class="headerlink" title="CountDownLatch: 减少计数"></a>CountDownLatch: 减少计数</h2><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行<br>减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法<br>之后的语句。</p>
<p>• CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，这<br>些线程会阻塞<br>• 其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程<br>不会阻塞)<br>• 当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//要等几个线程,构造参数就为几</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; go out&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;关门&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;tDownLatch.getCount());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="•-CyclicBarrier-循环栅栏"><a href="#•-CyclicBarrier-循环栅栏" class="headerlink" title="• CyclicBarrier: 循环栅栏"></a>• CyclicBarrier: 循环栅栏</h2><p>CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一<br>次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后<br>的语句。可以将 CyclicBarrier 理解为加 1 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义神龙召唤需要的龙珠总数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集齐 7 颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">//定义循环栅栏</span></span><br><span class="line">	<span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, () -&gt; &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;集齐&quot;</span> + NUMBER + <span class="string">&quot;颗龙珠,现在召唤神龙!!!!!!!!!&quot;</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">//定义 7 个线程分别去收集龙珠</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="comment">//   加final，变量会存在堆中的方法区里，子线程共享进程的堆，所以能读到。否则是存在另一个线程的栈中，不同线程读不到</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> i;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">&quot;龙珠 3 号&quot;</span>)) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;龙珠 3 号抢夺战开始,孙悟空开启超级赛亚人模式!&quot;</span>);</span><br><span class="line">					Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">					System.out.println(<span class="string">&quot;龙珠 3 号抢夺战结束,孙悟空打赢了,拿到了龙珠 3 号 !&quot;</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;龙珠&quot;</span> + temp + <span class="string">&quot;号收集到了 !!!!&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				cyclicBarrier.await();</span><br><span class="line">				System.out.println(<span class="string">&quot;龙珠&quot;</span> + temp + <span class="string">&quot;号结束&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">&quot;龙珠&quot;</span> + i + <span class="string">&quot;号&quot;</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="•-Semaphore-信号量"><a href="#•-Semaphore-信号量" class="headerlink" title="• Semaphore: 信号量"></a>• Semaphore: 信号量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//初始可用资源数</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//p操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取了资源&quot;</span>);</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//v操作</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放了资源&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;, String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-读写锁"><a href="#7-读写锁" class="headerlink" title="7.读写锁"></a>7.读写锁</h3><p>为什么要用读写锁:希望更加细腻的控制读写操作</p>
<table>
<thead>
<tr>
<th></th>
<th align="center"><strong>读写锁</strong></th>
<th align="right">Synchronized</th>
</tr>
</thead>
<tbody><tr>
<td>读-读</td>
<td align="center">√</td>
<td align="right">×</td>
</tr>
<tr>
<td>读-写</td>
<td align="center">×</td>
<td align="right">×</td>
</tr>
<tr>
<td>写-写</td>
<td align="center">×</td>
<td align="right">×</td>
</tr>
</tbody></table>
<p>读写锁对读操作也加锁,但这并不是为了阻止其他线程读,而是阻止其他线程写</p>
<p>api:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>()</span><br><span class="line"><span class="comment">//获取读锁并加锁</span></span><br><span class="line">readWriteLock.readLock.lock()</span><br><span class="line">readWriteLock.readLock.unlock()</span><br><span class="line">readWriteLock.writeLock.lock()</span><br><span class="line">readWriteLock.writeLock.unlock()</span><br></pre></td></tr></table></figure>

<h1 id="8-BlockingQueue"><a href="#8-BlockingQueue" class="headerlink" title="8.BlockingQueue"></a>8.BlockingQueue</h1><p>特点:队列满\空时会阻塞</p>
<p>offer():入队列时,如果队列满,会等待一段时间,然后再次尝试入队列,如果还满,就返回false</p>
<p><img src="C:\Users\xzwnp\AppData\Roaming\marktext\images\2022-07-28-15-53-58-image.png"></p>
<p>此外,可以使用element()方法查看队列首的元素</p>
<p>eg:d入队列时会被阻塞,2秒内由于a出队列了,2秒后d能够顺利入队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.offer(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">                System.out.println(queue.offer(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">                System.out.println(queue.offer(<span class="string">&quot;c&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">                <span class="comment">//如果没有位置,会等待2秒,如果队列还是满,就会抛出异常</span></span><br><span class="line">                System.out.println(queue.offer(<span class="string">&quot;d&quot;</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(queue.poll(<span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">                System.out.println(queue.poll(<span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">                System.out.println(queue.poll(<span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">                System.out.println(queue.poll(<span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><p>容量为1的队列</p>
<p>只有offer()、put(),没有add()</p>
<h1 id="9-线程池"><a href="#9-线程池" class="headerlink" title="9.线程池"></a>9.线程池</h1><p><strong>线程池的特点:</strong><br>1.线程会自动创建,自动销毁,我们只需要把任务(Runnable)提交给线程池即可<br>2.线程池创建时,线程数为0;任务提交时才会开始创建</p>
<h2 id="1-使用Executors创建线程的三种方法"><a href="#1-使用Executors创建线程的三种方法" class="headerlink" title="1.使用Executors创建线程的三种方法"></a>1.使用Executors创建线程的三种方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">建线程</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Executors创建线程的三种方式</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建只能有一个线程的线程池,(核心线程数为1,最大线程数为1) //阻塞队列最长长度为21亿</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">//创建拥有固定线程数量的线程池(核心线程数为nThread,最大线程数为nThread) //阻塞队列最长长度为21亿</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//创建一个拥有任意线程数量的线程池,当某个线程一段时间(1分钟)内未被使用,会被销毁</span></span><br><span class="line">        <span class="comment">//核心线程数为0,最大线程数为21亿</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool3</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//第一种方式处理任务 同时最多1个线程</span></span><br><span class="line"><span class="comment">//            threadPool.execute(task);</span></span><br><span class="line">            <span class="comment">//第二种方式处理任务 同时最多只有5个线程</span></span><br><span class="line"><span class="comment">//            threadPool2.execute(task);</span></span><br><span class="line">            <span class="comment">//第三种方式处理任务 理论同时能有100个线程,如果任务执行得快,是跑不到100个得(前面创建的线程被回收利用)</span></span><br><span class="line">            threadPool3.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用ThreadPoolExecutor手动创建-推荐"><a href="#2-使用ThreadPoolExecutor手动创建-推荐" class="headerlink" title="2.使用ThreadPoolExecutor手动创建(推荐)"></a>2.使用ThreadPoolExecutor手动创建(推荐)</h2><p>使用Executors创建线程,底层还是调用了ThreadPoolExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">                <span class="literal">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程池的两大关键:线程和阻塞队列</p>
<p>corePoolSize:核心线程数</p>
<p>maximumPoolSize:最大线程数     当阻塞队列满时,   便会创建更多线程,直到线程数&#x3D;最大线程数</p>
<p>keepAliveTime:非核心线程的存活时间。非核心线程如果一段时间内未被使用，就会被销毁</p>
<p>unit：与keepAliveTime配合使用</p>
<p>workQueue：指定的阻塞队列</p>
<p>threadFactory：一般不用管，用默认的就好</p>
<p>handler：阻塞队列满了，任务无法添加时的handler，如下图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Method that may be invoked by a &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125; when</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> ThreadPoolExecutor#execute execute&#125; cannot accept a</span></span><br><span class="line"><span class="comment">     * task.  This may occur when no more threads or queue slots are</span></span><br><span class="line"><span class="comment">     * available because their bounds would be exceeded, or upon</span></span><br><span class="line"><span class="comment">     * shutdown of the Executor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;In the absence of other alternatives, the method may throw</span></span><br><span class="line"><span class="comment">     * an unchecked &#123;<span class="doctag">@link</span> RejectedExecutionException&#125;, which will be</span></span><br><span class="line"><span class="comment">     * propagated to the caller of &#123;<span class="doctag">@code</span> execute&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executor the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if there is no remedy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//可以自定义handler</span></span><br><span class="line"><span class="comment">//        RejectedExecutionHandler handler = (Runnable r, ThreadPoolExecutor e) -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span></span><br><span class="line"><span class="comment">//                    &quot; rejected from &quot; +</span></span><br><span class="line"><span class="comment">//                    e.toString());</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        <span class="comment">//handler:阻塞队列满了抛出异常</span></span><br><span class="line">        <span class="type">RejectedExecutionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy();</span><br><span class="line">        ArrayBlockingQueue&lt;Runnable&gt; taskQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60</span>,</span><br><span class="line">                TimeUnit.SECONDS, taskQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池,否则程序会一直运行</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>4种拒绝handler:</p>
<p><img src="C:\Users\xzwnp\AppData\Roaming\marktext\images\2022-07-29-19-07-46-image.png"></p>
<p>如何定义线程池的最大线程数:</p>
<p><img src="C:\Users\xzwnp\AppData\Roaming\marktext\images\2022-07-29-19-17-51-image.png"></p>
<h2 id="3-线程池的工作顺序"><a href="#3-线程池的工作顺序" class="headerlink" title="3.线程池的工作顺序"></a>3.线程池的工作顺序</h2><p>以ThreadPoolExecutor来说明:</p>
<p>0.创建线程池,核心线程为懒加载,不会立即创建</p>
<p>1.核心线程满了,还有请求进来,放入阻塞队列</p>
<p>2.阻塞队列也满了,开始创建非核心线程来执行</p>
<p>3.如果非核心线程也满了,使用RejectHandler</p>
<p>也有许多特例,比如tomcat的线程池是直接开最大线程来执行的 ,达到了才丢队列</p>
<h1 id="10-四大函数式接口"><a href="#10-四大函数式接口" class="headerlink" title="10.四大函数式接口"></a>10.四大函数式接口</h1><h2 id="1、Function-函数式接口"><a href="#1、Function-函数式接口" class="headerlink" title="1、Function 函数式接口"></a>1、Function 函数式接口<img src="https://img-blog.csdnimg.cn/95fe3a76d97949c5875b930821920d15.png"></h2><p><img src="https://img-blog.csdnimg.cn/eca6d881112247fba82b1b90ae9b3b48.png"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//两个泛型</span></span><br><span class="line">    <span class="comment">//功能:输出输入的字符串</span></span><br><span class="line">    Function&lt;String, String&gt; echo = str -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(echo.apply(<span class="string">&quot;你好啊&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、Predicate-测试型接口"><a href="#2、Predicate-测试型接口" class="headerlink" title="2、Predicate 测试型接口"></a>2、Predicate 测试型接口</h2><p><img src="https://img-blog.csdnimg.cn/5dc523d902f0464d92e1625776cf2f0c.png"> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Predicate:输入参数泛型,返回值为bool</span></span><br><span class="line">        <span class="comment">//功能:判断输入的字符串是否为空</span></span><br><span class="line"><span class="comment">//        Predicate&lt;String&gt; predicate = str-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            return str.isEmpty();</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line">        Predicate&lt;String&gt; predicate =String::isEmpty;</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;123&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、Consumer-消费型接口"><a href="#3、Consumer-消费型接口" class="headerlink" title="3、Consumer 消费型接口"></a>3、Consumer 消费型接口</h2><p>有参数 没有返回值</p>
<p><img src="https://img-blog.csdnimg.cn/09fd8be151a244ecbef5afc95701276d.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haust.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Supplier 供给型接口 没有参数，只有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*Supplier supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;get()&quot;);</span></span><br><span class="line"><span class="comment">                return 1024;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Supplier</span> <span class="variable">supplier</span> <span class="operator">=</span> ()-&gt;&#123; <span class="keyword">return</span> <span class="number">1024</span>; &#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、Supplier-供给型接口"><a href="#4、Supplier-供给型接口" class="headerlink" title="4、Supplier 供给型接口"></a>4、Supplier 供给型接口</h2><p>没有参数 只有返回值<img src="https://img-blog.csdnimg.cn/c338e0171fa149008788d1a40143f2b3.png"></p>
<p> <img src="https://img-blog.csdnimg.cn/128b715f40c14c55a20b74301b566fc0.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.haust.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Supplier 供给型接口 没有参数，只有返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*Supplier supplier = new Supplier&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public Integer get() &#123;</span></span><br><span class="line"><span class="comment">                System.out.println(&quot;get()&quot;);</span></span><br><span class="line"><span class="comment">                return 1024;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Supplier</span> <span class="variable">supplier</span> <span class="operator">=</span> ()-&gt;&#123; <span class="keyword">return</span> <span class="number">1024</span>; &#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-volatile关键字"><a href="#10-volatile关键字" class="headerlink" title="10.volatile关键字"></a>10.volatile关键字</h1><p>volatile是Java<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>提供的轻量级的同步机制，它有３个特性：<br>１）<strong>保证可见性</strong><br>２）<strong>不保证原子性</strong><br>３）<strong>禁止指令重排</strong></p>
<h2 id="１）保证可见性"><a href="#１）保证可见性" class="headerlink" title="１）保证可见性"></a>１）保证可见性</h2><h3 id="1-1、什么是JMM模型？"><a href="#1-1、什么是JMM模型？" class="headerlink" title="1.1、什么是JMM模型？"></a>1.1、什么是JMM模型？</h3><p>要想理解什么是可见性，首先要先理解JMM。</p>
<p>JMM（Java内存模型，Java Memory Model）本身是一种抽象的概念，并不真实存在。它描述的是一组规则或规范，通过这组规范，定了程序中各个变量的访问方法。JMM关于同步的规定：<br>１）线程解锁前，必须把共享变量的值刷新回主内存；<br>２）线程加锁前，必须读取主内存的最新值到自己的工作内存；<br>３）加锁解锁是同一把锁；</p>
<p>由于JVM运行程序的实体是线程，创建每个线程时，JMM会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域。</p>
<p>Java内存模型规定<strong>所有变量都存储在主内存</strong>，主内存是共享内存区域，所有线程都可以访问。</p>
<p>**但线程对变量的操作（读取、赋值等）必须在工作内存中进行。因此首先要将变量从主内存拷贝到自己的工作内存，然后对变量进行操作，操作完成后再将变量写会主内存中。</p>
<p>**</p>
<h3 id="1-2代码验证可见性"><a href="#1-2代码验证可见性" class="headerlink" title="1.2代码验证可见性:"></a>1.2代码验证可见性:</h3><p>以下代码,线程会处于死循环,因为没有感知到主线程修改flag&#x3D;false</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试可见性</span></span><br><span class="line"><span class="comment">     * 在某些情况下,一个线程对共享变量的修改 可能 不会立刻</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                <span class="comment">//代码块要保持为空,不然共享变量会立刻写回内存</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="number">123</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1L</span>);</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案: 变量加上volatile关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>volatile关键字能保证当<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=volatile&spm=1001.2101.3001.7020">volatile</a>修饰的变量信息在其他线程中进行了变更，通过MESI缓存总线的<code>嗅探机制</code>，<code>及时通知其他线程</code>。<br>其他线程将其数据信息进行<code>失效</code>操作，<code>重新</code>从<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中<code>加载</code>数据。</p>
</blockquote>
<h2 id="２）不保证原子性"><a href="#２）不保证原子性" class="headerlink" title="２）不保证原子性"></a>２）不保证原子性</h2><p>开20个线程,每个线程执行100次a++,a可能为2000;</p>
<p>但开20个线程,每个线程执行1000次a++,a常常为19000左右的数;</p>
<p>这是因为i++并不是一个原子操作;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案:</p>
<p>1.对add()使用synchronized或者lock</p>
<p>2.使用AtomicInteger类</p>
<p>    getAndIncrement()方法能够进行原子的i++</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        a++;</span><br><span class="line">        b.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="３）禁止指令重排"><a href="#３）禁止指令重排" class="headerlink" title="３）禁止指令重排"></a>３）禁止指令重排</h2><p>编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。</p>
<h1 id="18、深入单例模式"><a href="#18、深入单例模式" class="headerlink" title="18、深入单例模式"></a>18、深入单例模式</h1><p>单例模式可以说只要是一个合格的开发都会写，但是如果要深究，小小的单例模式可以牵扯到很多东<br>西，比如<br>多线程是否安全，是否懒加载，性能等等。还有你知道几种单例模式的写法呢？如何防止反射破坏单例模式？今天，我们来探究单例模式。</p>
<p>关于单例模式的概念，在这里就不在阐述了，相信每个小伙伴都了如指掌。我们直接进入正题：</p>
<h2 id="1、饿汉式"><a href="#1、饿汉式" class="headerlink" title="1、饿汉式"></a>1、饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">hungry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hungry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式是最简单的单例模式的写法，保证了线程的安全，在很长的时间里，我都是饿汉模式来完成单例<br>的，因为够简单，后来才知道饿汉式会有一点小问题，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hungry</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] data1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] data2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] data3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] data4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Hungry</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Hungry</span> <span class="variable">hungry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hungry</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hungry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Hungry类中，我定义了四个byte数组，当代码一运行，这四个数组就被初始化，并且放入内存了，如果长时间没有用到getInstance方法，不需要Hungry类的对象，这不是一种浪费吗？我希望的是<br>只有用到了<br>getInstance方法，才会去初始化单例类，才会加载单例类中的数据。所以就有了<br>第二种单例模</p>
<p>式：懒汉式。</p>
<h2 id="2、懒汉式"><a href="#2、懒汉式" class="headerlink" title="2、懒汉式"></a>2、懒汉式</h2><p>正常的 懒汉式单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">3</span>    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;Start&quot;</span>);</span><br><span class="line"><span class="number">4</span>    &#125;</span><br><span class="line"><span class="number">5</span>    </span><br><span class="line"><span class="number">6</span>    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"><span class="number">7</span>    </span><br><span class="line"><span class="number">8</span>    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">9</span>    <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">10</span>    lazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line"><span class="number">11</span>    &#125;</span><br><span class="line"><span class="number">12</span>    <span class="keyword">return</span> lazyMan;</span><br><span class="line"><span class="number">13</span>    &#125;</span><br><span class="line"><span class="number">14</span>    </span><br><span class="line"><span class="number">15</span>    <span class="comment">// 测试并发环境，发现单例失效</span></span><br><span class="line"><span class="number">16</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="number">17</span>    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="number">18</span>    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="number">19</span>    LazyMan.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="number">20</span>                &#125;).start();</span><br><span class="line"><span class="number">21</span>            &#125;    </span><br><span class="line"><span class="number">22</span>        &#125;        </span><br><span class="line"><span class="number">23</span>    &#125;            </span><br></pre></td></tr></table></figure>

<p>多加一层检测可以避免问题，也就是DCL懒汉式！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line">            lazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DCL懒汉式的单例，保证了线程的安全性，又符合了懒加载，只有在用到的时候，才会去初始化，调用效率也比较高，但是这种写法在极端情况还是可能会有一定的问题。因为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br></pre></td></tr></table></figure>

<p>不是原子性操作，至少会经过三个步骤：</p>
<ol>
<li><p>分配对象内存空间</p>
</li>
<li><p>执行构造方法初始化对象</p>
</li>
<li><p>设置instance指向刚分配的内存地址，此时instance ！&#x3D;null；</p>
</li>
</ol>
<p>由于指令重排，导致A线程执行 lazyMan &#x3D; new<br>LazyMan();的时候，可能先执行了第三步（还没执行第二步），此时线程B又进来了，发现lazyMan已经不为空了，直接返回了lazyMan，并且后面使用了返回<br>的lazyMan，由于线程A还没有执行第二步，导致此时lazyMan还不完整，可能会有一些意想不到的错误，所以就有了下面一种单例模式。</p>
<p>这种单例模式只是在上面DCL单例模式增加一个volatile关键字来避免指令重排：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line"><span class="number">2</span>    <span class="keyword">private</span> <span class="title function_">LazyMan</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">3</span>    &#125;</span><br><span class="line"><span class="number">4</span>    </span><br><span class="line"><span class="number">5</span>    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"><span class="number">6</span>    </span><br><span class="line"><span class="number">7</span>    <span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="number">8</span>    <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">9</span>    <span class="keyword">synchronized</span> (LazyMan.class) &#123;</span><br><span class="line"><span class="number">10</span>    <span class="keyword">if</span> (lazyMan == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="number">11</span>    lazyMan = <span class="keyword">new</span> <span class="title class_">LazyMan</span>();</span><br><span class="line"><span class="number">12</span>    &#125;</span><br><span class="line"><span class="number">13</span>    &#125;</span><br><span class="line"><span class="number">14</span>    &#125;</span><br><span class="line"><span class="number">15</span>    <span class="keyword">return</span> lazyMan;</span><br><span class="line"></span><br><span class="line"><span class="number">16</span>        &#125;</span><br><span class="line"><span class="number">17</span>    &#125;    </span><br></pre></td></tr></table></figure>

<h2 id="3、静态内部类"><a href="#3、静态内部类" class="headerlink" title="3、静态内部类"></a>3、静态内部类</h2><p>还有这种方式是第一种饿汉式的改进版本，同样也是在类中定义static变量的对象，并且直接初始化，不过是移到了静态内部类中，十分巧妙。既保证了线程的安全性，同时又满足了懒加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Holder</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Holder <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> InnerClass.holder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Holder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Holder</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、万恶的反射"><a href="#4、万恶的反射" class="headerlink" title="4、万恶的反射"></a>4、万恶的反射</h2><p>万恶的反射登场了，反射是一个比较霸道的东西，无视private修饰的构造方法，可以直接在外面</p>
<p>newInstance，破坏我们辛辛苦苦写的单例模式。</p>
<p>我们分别打印出lazyMan1，lazyMan2的hashcode，lazyMan1是否相等lazyMan2，结果显而易见，<strong>不相等；</strong></p>
<p>那么，怎么解决这种问题呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">lazyMan1</span> <span class="operator">=</span> LazyMan.getInstance();</span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="literal">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">LazyMan</span> <span class="variable">lazyMan2</span> <span class="operator">=</span> declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(lazyMan1.hashCode());</span><br><span class="line">        System.out.println(lazyMan2.hashCode());</span><br><span class="line">        System.out.println(lazyMan1 == lazyMan2);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在私有的构造函数中做一个判断，如果lazyMan不为空，说明lazyMan已经被创建过了，如果正常调用</p>
<p>getInstance方法，是不会出现这种事情的，所以直接抛出异常！</p>
<p>但是这种写法还是有问题：</p>
<p>上面我们是先正常的调用了getInstance方法，创建了LazyMan对象，所以第二次用反射创建对象，私有<br>构造函数里面的判断起作用了，反射破坏单例模式失败。但是如果破坏者干脆不先调用getInstance方<br>法，一上来就直接用反射创建对象，我们的判断就不生效了：</p>
<p>那么如何防止这种反射破坏呢？</p>
<p>+—+—+—————————————————————+<br>| 2 | | &gt; } |<br>| 2 | | |<br>+—+—+—————————————————————+<br>| 2 | } | |<br>| 3 | | |<br>+—+—+—————————————————————+</p>
<p>在这里，我定义了一个boolean变量ﬂag，初始值是false，私有构造函数里面做了一个判断，如果ﬂag&#x3D;false，就把ﬂag改为true，但是如果ﬂag等于true，就说明有问题了，因为正常的调用是不会第二<br>次跑到私有构造方法的，所以抛出异常。</p>
<p>看起来很美好，但是还是不能完全防止反射破坏单例模式，因为可以利用反射修改ﬂag的值。</p>
<p>+—+——————————————————————+<br>| 1 | &gt; class Demo02{ |<br>+—+——————————————————————+<br>| 2 | &gt; public static void main(String[] args) { |<br>+—+——————————————————————+<br>| 3 | &gt; try { |<br>+—+——————————————————————+<br>| 4 | &gt; &#x2F;&#x2F; 通过反射创建对象 |<br>+—+——————————————————————+<br>| 5 | &gt; Constructor<LazyMan> declaredConstructor &#x3D; |<br>+—+——————————————————————+<br>| | &gt; LazyMan.class.getDeclaredConstructor(null); |<br>+—+——————————————————————+<br>| 6 | Field field &#x3D; LazyMan.class.getDeclaredField(“flag”); |<br>+—+——————————————————————+<br>| 7 | &gt; field.setAccessible(true); |<br>+—+——————————————————————+<br>| 8 | |<br>+—+——————————————————————+<br>| 9 | &gt; &#x2F;&#x2F; 通过反射实例化对象 |<br>+—+——————————————————————+<br>| 1 | &gt; declaredConstructor.setAccessible(true); |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | LazyMan lazyMan1 &#x3D; declaredConstructor.newInstance(); |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(field.get(lazyMan1)); |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(lazyMan1.hashCode()); |<br>| 3 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | &gt; &#x2F;&#x2F;通过反射，修改字段的值！ |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | &gt; field.set(lazyMan1,false); |<br>| 6 | |<br>+—+——————————————————————+<br>| 1 | LazyMan lazyMan2 &#x3D; declaredConstructor.newInstance(); |<br>| 7 | |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(field.get(lazyMan2)); |<br>| 8 | |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(lazyMan2.hashCode()); |<br>| 9 | |<br>+—+——————————————————————+<br>| 2 | |<br>| 0 | |<br>+—+——————————————————————+<br>| 2 | &gt; } catch (Exception e) { |<br>| 1 | |<br>+—+——————————————————————+<br>| 2 | &gt; e.printStackTrace(); |<br>| 2 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 3 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 4 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 5 | |<br>+—+——————————————————————+</p>
<p>并没有一个很好的方案去避免反射破坏单例模式，所以轮到我们的枚举登场了。</p>
<h2 id="5、枚举"><a href="#5、枚举" class="headerlink" title="5、枚举"></a>5、枚举</h2><p>枚举类型是Java<br>5中新增特性的一部分，它是一种特殊的数据类型，之所以特殊是因为它既是一种类(class)类型却又比类类型多了些特殊的约束，但是这些约束的存在也造就了枚举类型的简洁性、安全性以及便捷性。</p>
<p>+—+——————————————————————+<br>| 1 | &gt; public enum EnumSingleton { |<br>+—+——————————————————————+<br>| 2 | &gt; INSTANCE; |<br>+—+——————————————————————+<br>| 3 | &gt; public EnumSingleton getInstance(){ |<br>+—+——————————————————————+<br>| 4 | &gt; return INSTANCE; |<br>+—+——————————————————————+<br>| 5 | &gt; } |<br>+—+——————————————————————+<br>| 6 | &gt; } |<br>+—+——————————————————————+<br>| 7 | |<br>+—+——————————————————————+<br>| 8 | &gt; class Demo04{ |<br>+—+——————————————————————+<br>| 9 | &gt; public static void main(String[] args) { |<br>+—+——————————————————————+<br>| 1 | &gt; EnumSingleton singleton1&#x3D;EnumSingleton.INSTANCE; |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | &gt; EnumSingleton singleton2&#x3D;EnumSingleton.INSTANCE; |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(“正常情况下，实例化两个实例是否相同：”+ |<br>| 2 | |<br>+—+——————————————————————+<br>| | &gt; (singleton1&#x3D;&#x3D;singleton2)); |<br>+—+——————————————————————+</p>
<p>+—+—+—————————————————————+<br>| 1 | | &gt; } |<br>| 3 | | |<br>+—+—+—————————————————————+<br>| 1 | } | |<br>| 4 | | |<br>+—+—+—————————————————————+</p>
<p>枚举是目前最推荐的单例模式的写法，因为足够简单，不需要开发自己保证线程的安全，同时又可以有<br>效的防止反射破坏我们的单例模式，我们可以看下newInstance的源码：</p>
<blockquote>
<p>{width&#x3D;”0.1667432195975503in”<br>height&#x3D;”0.1667432195975503in”}img</p>
</blockquote>
<p>重点就是红框中圈出来的部分，如果枚举去newInstance就直接抛出异常了。</p>
<h3 id="反编译查看下枚举的源码"><a href="#反编译查看下枚举的源码" class="headerlink" title="反编译查看下枚举的源码"></a>反编译查看下枚举的源码</h3><p>+—+——————————————————————+<br>| 1 | &gt; javap -p EnumSingleton.class |<br>+—+——————————————————————+<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; Compiled from “EnumSingleton.java” |<br>+—+——————————————————————+<br>| 4 | &gt; public final class 单例模式.EnumSingleton extends |<br>| | &gt; java.lang.Enum&lt;单例模 |<br>+—+——————————————————————+<br>| | &gt; 式.EnumSingleton&gt; { |<br>+—+——————————————————————+<br>| 5 | &gt; public static final 单例模式.EnumSingleton INSTANCE; |<br>+—+——————————————————————+<br>| 6 | &gt; private static final 单例模式.EnumSingleton[] $VALUES; |<br>+—+——————————————————————+<br>| 7 | &gt; public static 单例模式.EnumSingleton[] values(); |<br>+—+——————————————————————+<br>| 8 | &gt; public static 单例模式.EnumSingleton |<br>| | &gt; valueOf(java.lang.String); |<br>+—+——————————————————————+<br>| 9 | &gt; private 单例模式.EnumSingleton(); |<br>+—+——————————————————————+<br>| 1 | &gt; public 单例模式.EnumSingleton getInstance(); |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | &gt; static {}; |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 2 | |<br>+—+——————————————————————+</p>
<p>这个看的不清楚，我们可以下 jad 进行反编译，我们的素材中也都有！</p>
<p>+—+——————————————————————-+<br>| 1 | &gt; jad -sjava EnumSingleton.class |<br>+—+——————————————————————-+<br>| 2 | &gt; # 会生成一个java文件 |<br>+—+——————————————————————-+<br>| 3 | &gt; Parsing EnumSingleton.class… Generating EnumSingleton.java |<br>+—+——————————————————————-+</p>
<p>我们点开里面的源码</p>
<p>+—+——————————————————————+<br>| 1 | &gt; &#x2F;&#x2F; Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov. |<br>+—+——————————————————————+<br>| 2 | &gt; &#x2F;&#x2F; Jad home page: <a target="_blank" rel="noopener" href="http://www.kpdus.com/jad.html">http://www.kpdus.com/jad.html</a> |<br>+—+——————————————————————+<br>| 3 | &gt; &#x2F;&#x2F; Decompiler options: packimports(3) |<br>+—+——————————————————————+<br>| 4 | &gt; &#x2F;&#x2F; Source File Name: EnumSingleton.java |<br>+—+——————————————————————+<br>| 5 | |<br>+—+——————————————————————+<br>| 6 | &gt; package 53554F8B6A215F0F; |<br>+—+——————————————————————+<br>| 7 | |<br>+—+——————————————————————+<br>| 8 | |<br>+—+——————————————————————+<br>| 9 | &gt; public final class EnumSingleton extends Enum |<br>+—+——————————————————————+<br>| 1 | &gt; { |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; public static EnumSingleton[] values() |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | &gt; { |<br>| 3 | |<br>+—+——————————————————————+<br>| 1 | &gt; return (EnumSingleton[])$VALUES.clone(); |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 6 | |<br>+—+——————————————————————+<br>| 1 | &gt; public static EnumSingleton valueOf(String name) |<br>| 7 | |<br>+—+——————————————————————+<br>| 1 | &gt; { |<br>| 8 | |<br>+—+——————————————————————+<br>| 1 | &gt; return |<br>| 9 | &gt; (EnumSingleton)Enum.valueOf(53554F8B6A215F0F&#x2F;EnumSingleton, |<br>+—+——————————————————————+<br>| | &gt; name); |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 0 | |<br>+—+——————————————————————+<br>| 2 | |<br>| 1 | |<br>+—+——————————————————————+<br>| 2 | &gt; private EnumSingleton(String s, int i) |<br>| 2 | |<br>+—+——————————————————————+<br>| 2 | &gt; { |<br>| 3 | |<br>+—+——————————————————————+</p>
<p>+—+—+—————————————————————+<br>| 2 | | &gt; super(s, i); |<br>| 4 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; } |<br>| 5 | | |<br>+—+—+—————————————————————+<br>| 2 | | |<br>| 6 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; public EnumSingleton getInstance() |<br>| 7 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; { |<br>| 8 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; return INSTANCE; |<br>| 9 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; } |<br>| 0 | | |<br>+—+—+—————————————————————+<br>| 3 | | |<br>| 1 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; public static final EnumSingleton INSTANCE; |<br>| 2 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; private static final EnumSingleton $VALUES[]; |<br>| 3 | | |<br>+—+—+—————————————————————+<br>| 3 | | |<br>| 4 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; static |<br>| 5 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; { |<br>| 6 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; INSTANCE &#x3D; new EnumSingleton(“INSTANCE”, 0); |<br>| 7 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; $VALUES &#x3D; (new EnumSingleton[] { |<br>| 8 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; INSTANCE |<br>| 9 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; }); |<br>| 0 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; } |<br>| 1 | | |<br>+—+—+—————————————————————+<br>| 4 | } | |<br>| 2 | | |<br>+—+—+—————————————————————+</p>
<p>再次尝试破坏看一下！</p>
<p>+—+——————————————————————+<br>| 1 | &gt; package 单例模式; |<br>+—+——————————————————————+<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; import java.lang.reflect.Constructor; |<br>+—+——————————————————————+<br>| 4 | |<br>+—+——————————————————————+<br>| 5 | &gt; public enum EnumSingleton { |<br>+—+——————————————————————+<br>| 6 | &gt; INSTANCE; |<br>+—+——————————————————————+<br>| 7 | &gt; public EnumSingleton getInstance(){ |<br>+—+——————————————————————+<br>| 8 | &gt; return INSTANCE; |<br>+—+——————————————————————+<br>| 9 | &gt; } |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; class Demo04{ |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | &gt; public static void main(String[] args) throws Exception { |<br>| 3 | |<br>+—+——————————————————————+<br>| 1 | &gt; EnumSingleton singleton1&#x3D;EnumSingleton.INSTANCE; |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | &gt; EnumSingleton singleton2&#x3D;EnumSingleton.INSTANCE; |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(“正常情况下，实例化两个实例是否相同：”+ |<br>| 6 | |<br>+—+——————————————————————+<br>| | &gt; (singleton1&#x3D;&#x3D;singleton2)); |<br>+—+——————————————————————+<br>| 1 | &gt; &#x2F;&#x2F;Constructor<EnumSingleton> constructor &#x3D; |<br>| 7 | |<br>+—+——————————————————————+<br>| | &gt; EnumSingleton.class.getDeclaredConstructor(); |<br>| | &gt; &#x2F;&#x2F;自身的类没有无参构造方法 |<br>+—+——————————————————————+<br>| 1 | &gt; Constructor<EnumSingleton> constructor &#x3D; |<br>| 8 | |<br>+—+——————————————————————+<br>| | &gt; Enu |<br>| | mSingleton.class.getDeclaredConstructor(String.class,int.class); |<br>+—+——————————————————————+<br>| 1 | &gt; constructor.setAccessible(true); |<br>| 9 | |<br>+—+——————————————————————+<br>| 2 | &gt; EnumSingleton enumSingleton &#x3D; constructor.newInstance(); |<br>| 0 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 1 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 2 | |<br>+—+——————————————————————+</p>
<p>试图破坏，真的破坏不了！</p>
<p>假如有人问你单例模式，再也不用害怕了。</p>
<h1 id="19、深入理解CAS"><a href="#19、深入理解CAS" class="headerlink" title="19、深入理解CAS"></a>19、深入理解CAS</h1><p>前言：互联网缩招之下，初级程序员大量过剩，高级程序员重金难求，除非你不吃这碗饭，否则就要逼<br>自己提升！</p>
<p>用代码理解下什么是CAS：</p>
<p>+—+——————————————————————+<br>| 1 | &gt; package com.kuang; |<br>+—+——————————————————————+<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; import java.util.concurrent.atomic.AtomicInteger; |<br>+—+——————————————————————+<br>| 4 | |<br>+—+——————————————————————+<br>| 5 | &gt; &#x2F;** |<br>+—+——————————————————————+<br>| 6 | &gt; * CAS : 比较并交换 compareAndSet |<br>+—+——————————————————————+<br>| 7 | &gt; * |<br>+—+——————————————————————+<br>| 8 | &gt; * 参数：期望值，更新值 |<br>+—+——————————————————————+<br>| 9 | &gt; * public final boolean compareAndSet(int expect, int update) |<br>| | &gt; { |<br>+—+——————————————————————+<br>| 1 | &gt; * return unsafe.compareAndSwapInt(this, valueOffset, expect, |<br>| 0 | &gt; update); |<br>+—+——————————————————————+<br>| 1 | &gt; * } |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; * @author 狂神说Java <a href="mailto:24736743@qq.com">24736743@qq.com</a> |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | &gt; *&#x2F; |<br>| 3 | |<br>+—+——————————————————————+<br>| 1 | &gt; public class CASDemo { |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | &gt; public static void main(String[] args) { |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | &gt; AtomicInteger atomicInteger &#x3D; new AtomicInteger(5); |<br>| 6 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 7 | |<br>+—+——————————————————————+<br>| 1 | &gt; &#x2F;&#x2F; main do somethings… |<br>| 8 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 9 | |<br>+—+——————————————————————+<br>| 2 | &gt; &#x2F;&#x2F; 期望的是5，后面改为 2020 ， 所以结果为 true，2020 |<br>| 0 | |<br>+—+——————————————————————+<br>| 2 | &gt; System.out.println(atomicInteger.compareAndSet(5, |<br>| 1 | |<br>+—+——————————————————————+<br>| | &gt; 2020)+”&#x3D;&gt;”+atomicInteger.get()); |<br>+—+——————————————————————+<br>| 2 | |<br>| 2 | |<br>+—+——————————————————————+<br>| 2 | &gt; &#x2F;&#x2F; 期望的是5，后面改为 1024 ， 所以结果为 false，2020 |<br>| 3 | |<br>+—+——————————————————————+<br>| 2 | &gt; System.out.println(atomicInteger.compareAndSet(5, |<br>| 4 | |<br>+—+——————————————————————+<br>| | &gt; 1024)+”&#x3D;&gt;”+atomicInteger.get()); |<br>+—+——————————————————————+<br>| 2 | |<br>| 5 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 6 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 7 | |<br>+—+——————————————————————+</p>
<p>一句话：真实值和期望值相同，就修改成功，真实值和期望值不同，就修改失败！</p>
<blockquote>
<p>这里的自增 + 1怎么实现的！</p>
</blockquote>
<p>+—+———————————————+—+—————–+<br>| 1 | atomicInteger.getAndIncrement(); &#x2F;&#x2F; | &gt; | &gt; 安全的问题 |<br>| | 分析源码，如何实现的 | | |<br>| | | i | |<br>| | | + | |<br>| | | + | |<br>+—+———————————————+—+—————–+<br>| 2 | | | |<br>+—+———————————————+—+—————–+<br>| 3 | &gt; public final int getAndIncrement() { &#x2F;&#x2F; | | |<br>| | &gt; 继续走源码 | | |<br>+—+———————————————+—+—————–+<br>| 4 | &gt; &#x2F;&#x2F; this 当前对象 | | |<br>+—+———————————————+—+—————–+<br>| 5 | &gt; &#x2F;&#x2F; valueOffset 内存偏移量，内存地址 | | |<br>+—+———————————————+—+—————–+<br>| 6 | &gt; &#x2F;&#x2F; 1.固定写死 | | |<br>+—+———————————————+—+—————–+<br>| 7 | return unsafe.getAndAddInt(this, | | |<br>| | valueOffset, 1); | | |<br>+—+———————————————+—+—————–+<br>| 8 | &gt; } | | |<br>+—+———————————————+—+—————–+</p>
<p>发现到了 字节码文件，我们已经无法在这里操作了！</p>
<p>{width&#x3D;”6.180880358705162in”<br>height&#x3D;”2.725311679790026in”}</p>
<p>{width&#x3D;”0.1667432195975503in”<br>height&#x3D;”0.1667432195975503in”}需要去到JDK安装目录下的 rt.jar<br>包下寻找了！而且这个类中的方法大部分都是 native 的方法了！<br>问题：这个UnSafe类到底是什么？ 可以看到AtomicInteger源码中也是它！</p>
<blockquote>
<p>1</p>
</blockquote>
<h3 id="1、UnSafe"><a href="#1、UnSafe" class="headerlink" title="1、UnSafe"></a>1、UnSafe</h3><p>UnSafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，<br>UnSafe相当于一个后门，基于该类可以直接操作特定内存的数据，Unsafe类存在于<br>sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe类的方法。</p>
<p>注意：Unsafe类中的所有方法都是Native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层<br>资源执行相应任务</p>
<h3 id="2、变量valueOffset"><a href="#2、变量valueOffset" class="headerlink" title="2、变量valueOffset"></a>2、变量valueOffset</h3><p>表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。</p>
<h3 id="3、变量-value用volatile修饰，保证了多线程之间的内存可见性"><a href="#3、变量-value用volatile修饰，保证了多线程之间的内存可见性" class="headerlink" title="3、变量 value用volatile修饰，保证了多线程之间的内存可见性"></a>3、变量 value用volatile修饰，保证了多线程之间的内存可见性</h3><p>CAS 的全称为 Compare-And-Swap，它是一条CPU并发原语。</p>
<p>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。</p>
<p>CAS并发原语体现在JAVA语言中就是 sun.misc.Unsafe<br>类中的各个方法。调用UnSafe类中的CAS方法，<br>JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用于范畴，是由若干条指令组成的，用于完成某个功<br>能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU<br>的原子指令，不会造成所谓的数据不一致问题。</p>
<p>分析源码：</p>
<p>+—+——————————————————————+<br>| 1 | &gt; public final int getAndAddInt(Object var1, long var2, int |<br>| | &gt; var4) { |<br>+—+——————————————————————+<br>| 2 | &gt; int var5; |<br>+—+——————————————————————+<br>| 3 | &gt; do { |<br>+—+——————————————————————+<br>| 4 | &gt; &#x2F;&#x2F; 获取传入对象的地址 |<br>+—+——————————————————————+<br>| 5 | &gt; var5 &#x3D; this.getIntVolatile(var1, var2); |<br>+—+——————————————————————+<br>| 6 | &gt; &#x2F;&#x2F; 比较并交换，如果var1，var2 还是原来的 |<br>| | &gt; var5，就执行内存偏移+1； var5 + |<br>+—+——————————————————————+<br>| | &gt; var4 |<br>+—+——————————————————————+<br>| 7 | &gt; } while(!this.compareAndSwapInt(var1, var2, var5, var5 + |<br>| | &gt; var4)); |<br>+—+——————————————————————+<br>| 8 | |<br>+—+——————————————————————+<br>| 9 | &gt; return var5; |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 0 | |<br>+—+——————————————————————+</p>
<p>Unsafe 类中的 compareAndSwapint，是一个本地方法，该方法的实现位于<br>unsafe.cpp 中；</p>
<p>{width&#x3D;”6.215690069991251in”<br>height&#x3D;”1.2578116797900263in”}</p>
<h3 id="CAS（CompareAndSwap）"><a href="#CAS（CompareAndSwap）" class="headerlink" title="CAS（CompareAndSwap）"></a>CAS（CompareAndSwap）</h3><p>比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作<br>内存中的值一致为止。</p>
<h3 id="CAS-应用"><a href="#CAS-应用" class="headerlink" title="CAS 应用"></a>CAS 应用</h3><p>CAS 有3个操作数，内存值V，旧的预期值A，要修改的更新值B。且仅当预期值A 和<br>内存值 V 相同时， 将内存值 V 修改为B，否则什么都不做。</p>
<h3 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h3><p>1、循环时间长开销很大。</p>
<blockquote>
<p>可以看到源码中存在 一个 do…while<br>操作，如果CAS失败就会一直进行尝试。</p>
</blockquote>
<p>2、只能保证一个共享变量的原子操作。</p>
<blockquote>
<p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作。但是：</p>
<p>对多个共享变量操作时，循环CAS就无法保证操作的原子性，这时候就可以用锁来保证原子性。</p>
</blockquote>
<p>3、引出来 ABA 问题？？？</p>
<h1 id="20、原子引用"><a href="#20、原子引用" class="headerlink" title="20、原子引用"></a>20、原子引用</h1><p>CAS &#x3D;&gt; UnSafe &#x3D;&gt; CAS 底层思想 &#x3D;&gt; ABA &#x3D;&gt; 原子引用更新 &#x3D;&gt;<br>如何规避ABA问题</p>
<h3 id="ABA问题怎么产生的？"><a href="#ABA问题怎么产生的？" class="headerlink" title="ABA问题怎么产生的？"></a>ABA问题怎么产生的？</h3><p>CAS会导致 “ABA问题”。狸猫换太子</p>
<p>CAS算法实现一个重要前提：需要取出内存中某时刻的数据并在当下时刻比较并交换，那么在这个时间差内会导致数据的变化</p>
<p>比如说一个线程one从内存位置V中取出A，这个时候另一个线程two也从内存中取出A，并且线程two进行了一些操作将值变成了B，然后线程two又将<br>V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后线程one操作成功。</p>
<p>尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p>
<p>{width&#x3D;”6.197257217847769in”<br>height&#x3D;”3.103853893263342in”}</p>
<p>+—+——————————————————————+<br>| 1 | &gt; package com.kuang; |<br>+—+——————————————————————+<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; import java.util.concurrent.atomic.AtomicReference; |<br>+—+——————————————————————+<br>| 4 | |<br>+—+——————————————————————+<br>| 5 | &gt; public class AtomicReferenceDemo { |<br>+—+——————————————————————+<br>| 6 | &gt; public static void main(String[] args) { |<br>+—+——————————————————————+<br>| 7 | &gt; User zhangsan &#x3D; new User(“zhangsan”, 22); |<br>+—+——————————————————————+<br>| 8 | &gt; User lisi &#x3D; new User(“lisi”, 25); |<br>+—+——————————————————————+<br>| 9 | |<br>+—+——————————————————————+<br>| 1 | &gt; AtomicReference<User> atomicReference &#x3D; new |<br>| 0 | &gt; AtomicReference&lt;&gt;(); |<br>+—+——————————————————————+<br>| 1 | &gt; atomicReference.set(zhangsan); &#x2F;&#x2F; 设置 |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | &gt; |<br>| 3 | System.out.print(atomicReference.compareAndSet(zhangsan,lisi)); |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(atomicReference.get().toString()); |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | &gt; |<br>| 6 | System.out.print(atomicReference.compareAndSet(zhangsan,lisi)); |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(atomicReference.get().toString()); |<br>| 7 | |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 8 | |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 9 | |<br>+—+——————————————————————+</p>
<p>+—+——————————————————————+<br>| 2 | |<br>| 0 | |<br>+—+——————————————————————+<br>| 2 | &gt; class User{ |<br>| 1 | |<br>+—+——————————————————————+<br>| 2 | &gt; String username; |<br>| 2 | |<br>+—+——————————————————————+<br>| 2 | &gt; int age; |<br>| 3 | |<br>+—+——————————————————————+<br>| 2 | |<br>| 4 | |<br>+—+——————————————————————+<br>| 2 | &gt; public User(String username, int age) { |<br>| 5 | |<br>+—+——————————————————————+<br>| 2 | &gt; this.username &#x3D; username; |<br>| 6 | |<br>+—+——————————————————————+<br>| 2 | &gt; this.age &#x3D; age; |<br>| 7 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 8 | |<br>+—+——————————————————————+<br>| 2 | |<br>| 9 | |<br>+—+——————————————————————+<br>| 3 | &gt; @Override |<br>| 0 | |<br>+—+——————————————————————+<br>| 3 | &gt; public String toString() { |<br>| 1 | |<br>+—+——————————————————————+<br>| 3 | &gt; return “User{“ + |<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; “username&#x3D;’” + username + ‘&#39;‘ + |<br>| 3 | |<br>+—+——————————————————————+<br>| 3 | &gt; “, age&#x3D;” + age + |<br>| 4 | |<br>+—+——————————————————————+<br>| 3 | &gt; ‘}’; |<br>| 5 | |<br>+—+——————————————————————+<br>| 3 | &gt; } |<br>| 6 | |<br>+—+——————————————————————+<br>| 3 | &gt; } |<br>| 7 | |<br>+—+——————————————————————+</p>
<h3 id="要解决ABA问题，我们就需要加一个版本号"><a href="#要解决ABA问题，我们就需要加一个版本号" class="headerlink" title="要解决ABA问题，我们就需要加一个版本号"></a>要解决ABA问题，我们就需要加一个版本号</h3><p>+——+———-+—–+—————————————-+—-+<br>| &gt; T1 | &gt; 100 | &gt; 1 | | |<br>+——+———-+—–+—————————————-+—-+<br>| &gt; T2 | &gt; 100 | &gt; 1 | &gt; &#x3D;&gt; 101 2 &#x3D;&gt; 100 | &gt; |<br>| | | | | 3 |<br>+——+———-+—–+—————————————-+—-+</p>
<p>{width&#x3D;”6.1579265091863515in”<br>height&#x3D;”3.2814577865266843in”}</p>
<p>演示ABA问题：</p>
<p>+—+——————————————————————+<br>| 1 | &gt; &#x2F;** |<br>+—+——————————————————————+<br>| 2 | &gt; * ABA 问题的解决 AtomicStampedReference |<br>+—+——————————————————————+<br>| 3 | &gt; *&#x2F; |<br>+—+——————————————————————+<br>| 4 | &gt; public class ABADemo { |<br>+—+——————————————————————+<br>| 5 | |<br>+—+——————————————————————+<br>| 6 | &gt; static AtomicReference<Integer> atomicReference &#x3D; new |<br>| | &gt; AtomicReference&lt;&gt; |<br>+—+——————————————————————+<br>| | &gt; (100); |<br>+—+——————————————————————+<br>| 7 | |<br>+—+——————————————————————+<br>| 8 | &gt; public static void main(String[] args) { |<br>+—+——————————————————————+</p>
<p>+—+——————————————————————+<br>| 9 | &gt; new Thread(()-&gt;{ |<br>+—+——————————————————————+<br>| 1 | &gt; atomicReference.compareAndSet(100,101); |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | &gt; atomicReference.compareAndSet(101,100); |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; },”T1”).start(); |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 3 | |<br>+—+——————————————————————+<br>| 1 | &gt; new Thread(()-&gt;{ |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | &gt; &#x2F;&#x2F; 暂停一秒钟，保证上面线程先执行 |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | &gt; try { |<br>| 6 | |<br>+—+——————————————————————+<br>| 1 | &gt; TimeUnit.SECONDS.sleep(1); |<br>| 7 | |<br>+—+——————————————————————+<br>| 1 | &gt; } catch (InterruptedException e) { |<br>| 8 | |<br>+—+——————————————————————+<br>| 1 | &gt; e.printStackTrace(); |<br>| 9 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 0 | |<br>+—+——————————————————————+<br>| 2 | &gt; System.out.println(atomicReference.compareAndSet(100, 2019)); |<br>| 1 | &gt; &#x2F;&#x2F; |<br>+—+——————————————————————+<br>| | &gt; 修改成功！ |<br>+—+——————————————————————+<br>| 2 | &gt; System.out.println(atomicReference.get()); |<br>| 2 | |<br>+—+——————————————————————+<br>| 2 | &gt; },”T2”).start(); |<br>| 3 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 4 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 5 | |<br>+—+——————————————————————+</p>
<p>解决方案：</p>
<p>+—+——————————————————————+<br>| 1 | &gt; package com.kuang; |<br>+—+——————————————————————+<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; import java.util.concurrent.TimeUnit; |<br>+—+——————————————————————+<br>| 4 | &gt; import java.util.concurrent.atomic.AtomicStampedReference; |<br>+—+——————————————————————+<br>| 5 | |<br>+—+——————————————————————+<br>| 6 | &gt; &#x2F;** |<br>+—+——————————————————————+<br>| 7 | &gt; * ABA 问题的解决 AtomicStampedReference |<br>+—+——————————————————————+<br>| 8 | &gt; * 注意变量版本号修改和获取问题。不要写错 |<br>+—+——————————————————————+<br>| 9 | &gt; *&#x2F; |<br>+—+——————————————————————+<br>| 1 | &gt; public class ABADemo { |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | static AtomicStampedReference<Integer> atomicStampedReference |<br>| 2 | &#x3D; new |<br>+—+——————————————————————+<br>| | &gt; AtomicStampedReference&lt;&gt;(100,1); |<br>+—+——————————————————————+<br>| 1 | |<br>| 3 | |<br>+—+——————————————————————+<br>| 1 | &gt; public static void main(String[] args) { |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | &gt; new Thread(()-&gt;{ |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | int stamp &#x3D; atomicStampedReference.getStamp(); &#x2F;&#x2F; 获得版本号 |<br>| 6 | |<br>+—+——————————————————————+<br>| 1 | &gt; System.out.println(“T1 stamp 01&#x3D;&gt;”+stamp); |<br>| 7 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 8 | |<br>+—+——————————————————————+<br>| 1 | &gt; &#x2F;&#x2F; 暂停2秒钟，保证下面线程获得初始版本号 |<br>| 9 | |<br>+—+——————————————————————+<br>| 2 | &gt; try { |<br>| 0 | |<br>+—+——————————————————————+<br>| 2 | &gt; TimeUnit.SECONDS.sleep(1); |<br>| 1 | |<br>+—+——————————————————————+<br>| 2 | &gt; } catch (InterruptedException e) { |<br>| 2 | |<br>+—+——————————————————————+<br>| 2 | &gt; e.printStackTrace(); |<br>| 3 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 4 | |<br>+—+——————————————————————+<br>| 2 | |<br>| 5 | |<br>+—+——————————————————————+<br>| 2 | &gt; atomicStampedReference.compareAndSet(100, 101, |<br>| 6 | |<br>+—+——————————————————————+<br>| | &gt; atomicStampedReference.getStamp() |<br>+—+——————————————————————+<br>| 2 | &gt; , |<br>| 7 | |<br>+—+——————————————————————+<br>| | &gt; atomicStampedReference.getStamp()+1); |<br>+—+——————————————————————+<br>| 2 | |<br>| 8 | |<br>+—+——————————————————————+<br>| 2 | &gt; System.out.println(“T1 stamp |<br>| 9 | |<br>+—+——————————————————————+<br>| | &gt; 02&#x3D;&gt;”+atomicStampedReference.getStamp()); |<br>+—+——————————————————————+<br>| 3 | |<br>| 0 | |<br>+—+——————————————————————+<br>| 3 | &gt; atomicStampedReference.compareAndSet(101, 100, |<br>| 1 | |<br>+—+——————————————————————+<br>| | &gt; atomicStampedReference.getStamp() |<br>+—+——————————————————————+</p>
<p>+—+——————————————————————+<br>| 3 | &gt; , |<br>| 2 | |<br>+—+——————————————————————+<br>| | &gt; atomicStampedReference.getStamp()+1); |<br>+—+——————————————————————+<br>| 3 | |<br>| 3 | |<br>+—+——————————————————————+<br>| 3 | &gt; System.out.println(“T1 stamp |<br>| 4 | |<br>+—+——————————————————————+<br>| | &gt; 03&#x3D;&gt;”+atomicStampedReference.getStamp()); |<br>+—+——————————————————————+<br>| 3 | &gt; },”T1”).start(); |<br>| 5 | |<br>+—+——————————————————————+<br>| 3 | |<br>| 6 | |<br>+—+——————————————————————+<br>| 3 | &gt; new Thread(()-&gt;{ |<br>| 7 | |<br>+—+——————————————————————+<br>| 3 | |<br>| 8 | |<br>+—+——————————————————————+<br>| 3 | &gt; int stamp &#x3D; atomicStampedReference.getStamp(); &#x2F;&#x2F; 获得版本号 |<br>| 9 | |<br>+—+——————————————————————+<br>| 4 | &gt; System.out.println(“T2 stamp 01&#x3D;&gt;”+stamp); |<br>| 0 | |<br>+—+——————————————————————+<br>| 4 | &gt; &#x2F;&#x2F; 暂停3秒钟，保证上面线程先执行 |<br>| 1 | |<br>+—+——————————————————————+<br>| 4 | &gt; try { |<br>| 2 | |<br>+—+——————————————————————+<br>| 4 | &gt; TimeUnit.SECONDS.sleep(3); |<br>| 3 | |<br>+—+——————————————————————+<br>| 4 | &gt; } catch (InterruptedException e) { |<br>| 4 | |<br>+—+——————————————————————+<br>| 4 | &gt; e.printStackTrace(); |<br>| 5 | |<br>+—+——————————————————————+<br>| 4 | &gt; } |<br>| 6 | |<br>+—+——————————————————————+<br>| 4 | |<br>| 7 | |<br>+—+——————————————————————+<br>| 4 | &gt; boolean result &#x3D; atomicStampedReference.compareAndSet(100, |<br>| 8 | &gt; 2019, |<br>+—+——————————————————————+<br>| | &gt; stamp, stamp + 1); |<br>+—+——————————————————————+<br>| 4 | &gt; System.out.println(“T2 是否修改成功 &#x3D;&gt;”+ result); |<br>| 9 | |<br>+—+——————————————————————+<br>| 5 | &gt; System.out.println(“T2 最新stamp |<br>| 0 | |<br>+—+——————————————————————+<br>| | &gt; &#x3D;&gt;”+atomicStampedReference.getStamp()); |<br>+—+——————————————————————+<br>| 5 | &gt; System.out.println(“T2 当前的最新值 |<br>| 1 | |<br>+—+——————————————————————+<br>| | &gt; &#x3D;&gt;”+atomicStampedReference.getReference()); |<br>+—+——————————————————————+<br>| 5 | |<br>| 2 | |<br>+—+——————————————————————+<br>| 5 | &gt; },”T2”).start(); |<br>| 3 | |<br>+—+——————————————————————+<br>| 5 | &gt; } |<br>| 4 | |<br>+—+——————————————————————+<br>| 5 | &gt; } |<br>| 5 | |<br>+—+——————————————————————+</p>
<h1 id="21、Java锁"><a href="#21、Java锁" class="headerlink" title="21、Java锁"></a>21、Java锁</h1><h2 id="1、公平锁非公平锁"><a href="#1、公平锁非公平锁" class="headerlink" title="1、公平锁非公平锁"></a>1、公平锁非公平锁</h2><p>公平锁：是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。</p>
<p>非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比现申请的线程<br>优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。</p>
<p>并发包中的 ReentrantLock 的创建可以指定构造函数 的<br>boolean类型来得到公平锁或者非公平锁，默认是非公平锁！</p>
<p>公平锁：就是很公平，在并发环境中，每个线程在获取到锁时会先查看此锁维护的等待队列，如果为<br>空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己。</p>
<p>非公平锁：非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就会采用类似公平锁那种方<br>式。</p>
<p>Java ReentrantLock<br>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。</p>
<p>对于Synchronized而言，也是一种非公平锁。</p>
<h2 id="2、可重入锁"><a href="#2、可重入锁" class="headerlink" title="2、可重入锁"></a>2、可重入锁</h2><p>可重入锁（也叫递归锁）</p>
<p>可重入锁又称递归锁，是指**同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提是锁对象得是同一个对象)**，不会因为之前已经获取过锁还没有释放而阻塞。</p>
<p>看以下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;a....&quot;</span>);</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">b</span><span class="params">()</span>&#123; </span><br><span class="line">    System.out.println(<span class="string">&quot;b....&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a方法和b方法用的是同一把锁(this),a需要调用b.</p>
<ul>
<li><p>如果一个锁是<strong>不可重入</strong>的,那么a调用b方法时,b需要获取锁,但是锁还在a身上,就获取不到锁,然后就死锁了。</p>
</li>
<li><p>如果锁是<strong>可重入的</strong>，由于a已经获得锁了，那么它调用b方法时就会自动获得锁，这就是<strong>重入</strong></p>
</li>
</ul>
<p>ReentrantLock、Synchronized 就是一个典型的可重入锁；</p>
<p>&#x3D;&#x3D;可见，锁应该被设计为可重入的&#x3D;&#x3D;，不然容易死锁</p>
<h3 id="可重入锁最大的作用就是避免死锁"><a href="#可重入锁最大的作用就是避免死锁" class="headerlink" title="可重入锁最大的作用就是避免死锁"></a>可重入锁最大的作用就是避免死锁</h3><h2 id="3、自旋锁"><a href="#3、自旋锁" class="headerlink" title="3、自旋锁"></a>3、自旋锁</h2><p>自旋锁（spinlock）</p>
<p>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下<br>文切换的消耗，缺点是循环会消耗CPU。</p>
<p>+—+——————————————————————+<br>| 1 | &gt; unsafe.getAndAddInt() |<br>+—+——————————————————————+<br>| 2 | &gt; public final int getAndAddInt(Object var1, long var2, int |<br>| | &gt; var4) { |<br>+—+——————————————————————+<br>| 3 | &gt; int var5; |<br>+—+——————————————————————+<br>| 4 | &gt; do { |<br>+—+——————————————————————+<br>| 5 | &gt; &#x2F;&#x2F; 获取传入对象的地址 |<br>+—+——————————————————————+<br>| 6 | &gt; var5 &#x3D; this.getIntVolatile(var1, var2); |<br>+—+——————————————————————+<br>| 7 | &gt; &#x2F;&#x2F; 比较并交换，如果var1，var2 还是原来的 |<br>| | &gt; var5，就执行内存偏移+1； var5 + |<br>+—+——————————————————————+<br>| | &gt; var4 |<br>+—+——————————————————————+<br>| 8 | &gt; } while(!this.compareAndSwapInt(var1, var2, var5, var5 + |<br>| | &gt; var4)); |<br>+—+——————————————————————+<br>| 9 | |<br>+—+——————————————————————+<br>| 1 | &gt; return var5; |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 1 | |<br>+—+——————————————————————+</p>
<p>测试代码：</p>
<p>+—+——————————————————————+<br>| 1 | &gt; package com.kuang; |<br>+—+——————————————————————+<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; import java.util.concurrent.TimeUnit; |<br>+—+——————————————————————+<br>| 4 | &gt; import java.util.concurrent.atomic.AtomicReference; |<br>+—+——————————————————————+<br>| 5 | |<br>+—+——————————————————————+<br>| 6 | &gt; public class SpinLockDemo { |<br>+—+——————————————————————+<br>| 7 | &gt; &#x2F;&#x2F; 原子引用线程, 没写参数，引用类型默认为null |<br>+—+——————————————————————+<br>| 8 | &gt; AtomicReference<Thread> atomicReference &#x3D; new |<br>| | &gt; AtomicReference&lt;&gt;(); |<br>+—+——————————————————————+<br>| 9 | |<br>+—+——————————————————————+<br>| 1 | &gt; &#x2F;&#x2F;上锁 |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | &gt; public void myLock(){ |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; Thread thread &#x3D; Thread.currentThread(); |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | &gt; Syst |<br>| 3 | em.out.println(Thread.currentThread().getName()+”&#x3D;&#x3D;&gt;mylock”); |<br>+—+——————————————————————+<br>| 1 | |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | &gt; &#x2F;&#x2F; 自旋 |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | &gt; while (!atomicReference.compareAndSet(null,thread)){ |<br>| 6 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 7 | |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 8 | |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 9 | |<br>+—+——————————————————————+</p>
<p>+—+—+—————————————————————+<br>| 2 | | |<br>| 0 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; &#x2F;&#x2F;解锁 |<br>| 1 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; public void myUnlock(){ |<br>| 2 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; Thread thread &#x3D; Thread.currentThread(); |<br>| 3 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; atomicReference.compareAndSet(thread,null); |<br>| 4 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; System.ou |<br>| 5 | | t.println(Thread.currentThread().getName()+”&#x3D;&#x3D;&gt;myUnlock”); |<br>+—+—+—————————————————————+<br>| 2 | | &gt; } |<br>| 6 | | |<br>+—+—+—————————————————————+<br>| 2 | | |<br>| 7 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; &#x2F;&#x2F; 测试 |<br>| 8 | | |<br>+—+—+—————————————————————+<br>| 2 | | &gt; public static void main(String[] args) { |<br>| 9 | | |<br>+—+—+—————————————————————+<br>| 3 | | |<br>| 0 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; SpinLockDemo spinLockDemo &#x3D; new SpinLockDemo(); |<br>| 1 | | |<br>+—+—+—————————————————————+<br>| 3 | | |<br>| 2 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; new Thread(()-&gt;{ |<br>| 3 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; spinLockDemo.myLock(); |<br>| 4 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; try { |<br>| 5 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; TimeUnit.SECONDS.sleep(5); |<br>| 6 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; } catch (InterruptedException e) { |<br>| 7 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; e.printStackTrace(); |<br>| 8 | | |<br>+—+—+—————————————————————+<br>| 3 | | &gt; } |<br>| 9 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; spinLockDemo.myUnlock(); |<br>| 0 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; },”T1”).start(); |<br>| 1 | | |<br>+—+—+—————————————————————+<br>| 4 | | |<br>| 2 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; try { |<br>| 3 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; TimeUnit.SECONDS.sleep(1); |<br>| 4 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; } catch (InterruptedException e) { |<br>| 5 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; e.printStackTrace(); |<br>| 6 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; } |<br>| 7 | | |<br>+—+—+—————————————————————+<br>| 4 | | |<br>| 8 | | |<br>+—+—+—————————————————————+<br>| 4 | | &gt; new Thread(()-&gt;{ |<br>| 9 | | |<br>+—+—+—————————————————————+<br>| 5 | | &gt; spinLockDemo.myLock(); |<br>| 0 | | |<br>+—+—+—————————————————————+<br>| 5 | | |<br>| 1 | | |<br>+—+—+—————————————————————+<br>| 5 | | &gt; try { |<br>| 2 | | |<br>+—+—+—————————————————————+<br>| 5 | | &gt; TimeUnit.SECONDS.sleep(1); |<br>| 3 | | |<br>+—+—+—————————————————————+<br>| 5 | | &gt; } catch (InterruptedException e) { |<br>| 4 | | |<br>+—+—+—————————————————————+<br>| 5 | | &gt; e.printStackTrace(); |<br>| 5 | | |<br>+—+—+—————————————————————+<br>| 5 | | &gt; } |<br>| 6 | | |<br>+—+—+—————————————————————+<br>| 5 | | |<br>| 7 | | |<br>+—+—+—————————————————————+<br>| 5 | | &gt; spinLockDemo.myUnlock(); |<br>| 8 | | |<br>+—+—+—————————————————————+<br>| 5 | | &gt; },”T2”).start(); |<br>| 9 | | |<br>+—+—+—————————————————————+<br>| 6 | | |<br>| 0 | | |<br>+—+—+—————————————————————+<br>| 6 | | &gt; } |<br>| 1 | | |<br>+—+—+—————————————————————+<br>| 6 | | |<br>| 2 | | |<br>+—+—+—————————————————————+<br>| 6 | } | |<br>| 3 | | |<br>+—+—+—————————————————————+</p>
<h2 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h2><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干<br>涉那它们都将无法推进下去，如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性<br>就很低，否者就会因为争夺有限的资源而陷入死锁。</p>
<p>{width&#x3D;”6.2017913385826775in”<br>height&#x3D;”3.0329166666666665in”}</p>
<h3 id="产生死锁主要原因："><a href="#产生死锁主要原因：" class="headerlink" title="产生死锁主要原因："></a>产生死锁主要原因：</h3><p>1、系统资源不足</p>
<p>2、进程运行推进的顺序不合适</p>
<p>3、资源分配不当</p>
<p>+—+——————————————————————+<br>| 1 | &gt; import java.util.concurrent.TimeUnit; |<br>+—+——————————————————————+<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; public class DeadLockDemo { |<br>+—+——————————————————————+<br>| 4 | &gt; public static void main(String[] args) { |<br>+—+——————————————————————+<br>| 5 | &gt; String lockA &#x3D; “lockA”; |<br>+—+——————————————————————+<br>| 6 | &gt; String lockB &#x3D; “lockB”; |<br>+—+——————————————————————+<br>| 7 | |<br>+—+——————————————————————+<br>| 8 | new Thread(new HoldLockThread(lockA,lockB),”T1”).start(); |<br>+—+——————————————————————+<br>| 9 | new Thread(new HoldLockThread(lockB,lockA),”T2”).start(); |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | &gt; } |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | &gt; class HoldLockThread implements Runnable{ |<br>| 3 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 4 | |<br>+—+——————————————————————+<br>| 1 | &gt; private String lockA; |<br>| 5 | |<br>+—+——————————————————————+<br>| 1 | &gt; private String lockB; |<br>| 6 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 7 | |<br>+—+——————————————————————+<br>| 1 | &gt; public HoldLockThread(String lockA, String lockB) { |<br>| 8 | |<br>+—+——————————————————————+<br>| 1 | &gt; this.lockA &#x3D; lockA; |<br>| 9 | |<br>+—+——————————————————————+<br>| 2 | &gt; this.lockB &#x3D; lockB; |<br>| 0 | |<br>+—+——————————————————————+<br>| 2 | &gt; } |<br>| 1 | |<br>+—+——————————————————————+<br>| 2 | |<br>| 2 | |<br>+—+——————————————————————+<br>| 2 | &gt; public void run() { |<br>| 3 | |<br>+—+——————————————————————+<br>| 2 | &gt; synchronized (lockA){ |<br>| 4 | |<br>+—+——————————————————————+<br>| 2 | |<br>| 5 | |<br>+—+——————————————————————+<br>| | &gt; System.out.print |<br>| | ln(Thread.currentThread().getName()+”lock:”+lockA+”&#x3D;&gt;get”+l |<br>+—+——————————————————————+<br>| | &gt; ockB); |<br>+—+——————————————————————+<br>| 2 | |<br>| 6 | |<br>+—+——————————————————————+</p>
<p>+—+——————————————————————+<br>| 2 | &gt; try { |<br>| 7 | |<br>+—+——————————————————————+<br>| 2 | &gt; TimeUnit.SECONDS.sleep(2); |<br>| 8 | |<br>+—+——————————————————————+<br>| 2 | &gt; } catch (InterruptedException e) { |<br>| 9 | |<br>+—+——————————————————————+<br>| 3 | &gt; e.printStackTrace(); |<br>| 0 | |<br>+—+——————————————————————+<br>| 3 | &gt; } |<br>| 1 | |<br>+—+——————————————————————+<br>| 3 | |<br>| 2 | |<br>+—+——————————————————————+<br>| 3 | &gt; synchronized (lockB){ |<br>| 3 | |<br>+—+——————————————————————+<br>| 3 | |<br>| 4 | |<br>+—+——————————————————————+<br>| | &gt; System.out.print |<br>| | ln(Thread.currentThread().getName()+”lock:”+lockB+”&#x3D;&gt;get”+l |<br>+—+——————————————————————+<br>| | &gt; ockA); |<br>+—+——————————————————————+<br>| 3 | &gt; } |<br>| 5 | |<br>+—+——————————————————————+<br>| 3 | |<br>| 6 | |<br>+—+——————————————————————+<br>| 3 | &gt; } |<br>| 7 | |<br>+—+——————————————————————+<br>| 3 | &gt; } |<br>| 8 | |<br>+—+——————————————————————+<br>| 3 | &gt; } |<br>| 9 | |<br>+—+——————————————————————+</p>
<h3 id="拓展java自带工具操作："><a href="#拓展java自带工具操作：" class="headerlink" title="拓展java自带工具操作："></a>拓展java自带工具操作：</h3><p>1、查看JDK目录的bin目录</p>
<p>2、使用</p>
<p>3、使用结果：</p>
<p>命令定位进程号</p>
<blockquote>
<p>找到死锁查看</p>
</blockquote>
<p>+—+——————————————————————+<br>| 1 | &gt; Java stack information for the threads listed above: |<br>+—+——————————————————————+<br>| 2 | &gt; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; |<br>+—+——————————————————————+<br>| 3 | &gt; “T2”: |<br>+—+——————————————————————+<br>| 4 | &gt; at com.kuang.HoldLockThread.run(DeadLockDemo.java:43) |<br>+—+——————————————————————+<br>| 5 | - waiting to lock &lt;0x00000000d5b87298&gt; (a java.lang.String) |<br>+—+——————————————————————+<br>| 6 | &gt; - locked &lt;0x00000000d5b872d0&gt; (a java.lang.String) |<br>+—+——————————————————————+<br>| 7 | &gt; at java.lang.Thread.run(Thread.java:748) |<br>+—+——————————————————————+<br>| 8 | &gt; “T1”: |<br>+—+——————————————————————+<br>| 9 | &gt; at com.kuang.HoldLockThread.run(DeadLockDemo.java:43) |<br>+—+——————————————————————+<br>| 1 | - waiting to lock &lt;0x00000000d5b872d0&gt; (a java.lang.String) |<br>| 0 | |<br>+—+——————————————————————+<br>| 1 | &gt; - locked &lt;0x00000000d5b87298&gt; (a java.lang.String) |<br>| 1 | |<br>+—+——————————————————————+<br>| 1 | &gt; at java.lang.Thread.run(Thread.java:748) |<br>| 2 | |<br>+—+——————————————————————+<br>| 1 | |<br>| 3 | |<br>+—+——————————————————————+<br>| 1 | &gt; Found 1 deadlock. |<br>| 4 | |<br>+—+——————————————————————+</p>
<p>问10个人，9个说看日志，还有一个分析堆栈信息，这一步，他就已经赢了</p>
<h1 id="22-completableFuture"><a href="#22-completableFuture" class="headerlink" title="22.completableFuture"></a>22.completableFuture</h1><p>特性:</p>
<ul>
<li>支持异步</li>
<li>可以获取返回结果</li>
<li>如果出现了异常,还可以先处理异常,然后正常返回</li>
<li>可以指定执行它的线程池</li>
</ul>
<h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程池,可不选</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">20</span>)</span><br><span class="line">                , Executors.defaultThreadFactory()</span><br><span class="line">                , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数为一个生产者</span></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;,executor).whenComplete((result, exception) -&gt; &#123;</span><br><span class="line">            <span class="comment">//当完成的时候回调这个</span></span><br><span class="line">            System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">            System.out.println(<span class="string">&quot;exception = &quot;</span> + exception);</span><br><span class="line">        &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">            <span class="comment">//触发异常需要做什么,可以指定返回值</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程总得做点什么,不然不像异步的&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取线程执行完毕的结果</span></span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>替换为handle方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;, executor).handle((res, e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;res = &quot;</span> + res);</span><br><span class="line">            System.out.println(<span class="string">&quot;e = &quot;</span> + e);</span><br><span class="line">            <span class="comment">//方法正常执行,直接返回,方法异常 返回一个默认值</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>



<h3 id="几个方法的比较"><a href="#几个方法的比较" class="headerlink" title="几个方法的比较"></a>几个方法的比较</h3><ul>
<li><p>whenComplete方法为任务执行完毕的回调(无论成功与否)只能感知结果的完成,却无法修改运行结果</p>
</li>
<li><p>exceptionally只在出现异常时被调用,可以修改返回结果</p>
</li>
<li><p>handle方法类似于whenComplete+exceptionally,在任务执行完毕时被回调,并且可以修改返回结果</p>
</li>
</ul>
<h2 id="2-Then方法"><a href="#2-Then方法" class="headerlink" title="2.Then方法:"></a>2.Then方法:</h2><p>分为两组进行比较:</p>
<h3 id="第一组"><a href="#第一组" class="headerlink" title="第一组:"></a>第一组:</h3><p>thenRun(Runnable action)</p>
<p>thenRunAsync(Runnable action)</p>
<p>thenRunAsync(Runnable action,Executor executor)</p>
<p>先上结论,三种方法相对于主线程都是异步的.区别在于使用的是哪个线程</p>
<p>使用以下代码进行测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">            <span class="number">5</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">20</span>)</span><br><span class="line">            , Executors.defaultThreadFactory()</span><br><span class="line">            , <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:执行了第一个任务&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;, executor)</span><br><span class="line">            .thenRunAsync(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:继续执行&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程总得做点什么,不然不像异步的&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;主线程再做点什么&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>thenRun:</p>
<p>使用执行第一个任务的线程,执行第二个任务</p>
<p><img src="https://power-image-uploader.oss-cn-guangzhou.aliyuncs.com/typora/image-20221104111221819.png" alt="image-20221104111221819"></p>
<p>使用的是上一个任务的线程池</p>
<p>thenRunAsync(Runnable action):由于第二个任务没有指定线程池,所以默认用了forkJoin(整个应用程序公用的线程池)线程池,这显然不太好。</p>
<p><img src="https://power-image-uploader.oss-cn-guangzhou.aliyuncs.com/typora/image-20221104110937950.png" alt="image-20221104110937950"></p>
<p>thenRunAsync(Runnable action,Executor executor)</p>
<p>使用指定的线程池，推荐</p>
<p><img src="https://power-image-uploader.oss-cn-guangzhou.aliyuncs.com/typora/image-20221104111151266.png" alt="image-20221104111151266"></p>
<h3 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thenRunAsync(Runnable action) //无参数 无返回值</span><br><span class="line">thenAcceptAsync(Consumer&lt;? super T&gt; action) //消费者,有参数,无返回值</span><br><span class="line">thenApplyAsync(Function&lt;? super T,? extends U&gt; fn) //有参数(result,exception),有返回值</span><br><span class="line">//没有thenSupply</span><br></pre></td></tr></table></figure>

<h3 id="RunAfterBoth"><a href="#RunAfterBoth" class="headerlink" title="RunAfterBoth"></a>RunAfterBoth</h3><p>需要两个任务都执行完毕了才会执行第三个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">future1.runAfterBoth(future2,()-&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="23-同步-异步-阻塞-非阻塞"><a href="#23-同步-异步-阻塞-非阻塞" class="headerlink" title="23.同步,异步,阻塞,非阻塞"></a>23.同步,异步,阻塞,非阻塞</h1><p>同步和异步关注的是几件事能不能同时进行 <strong>如果要实现异步,必然是多线程</strong>(同步可以是单线程)</p>
<p>阻塞和非阻塞关注的是能不能动</p>
<p>NIO(New IO)为什么是同步非阻塞IO:</p>
<p>非阻塞：线程在等待网络IO的同时,一直在处理其他事件:客户端连接事件,连接就绪事件,读事件,写事件。</p>
<p>同步：把数据从内核态拷贝到用户态，需要这个线程自己完成。</p>
<p>如果是异步非阻塞，拷贝数据应该交给另一个线程，另一个线程都准备好了才会去通知当前线程。</p>
<p>BIO，NIO，AIO的区别：</p>
<p>BIO是同步阻塞IO.</p>
<p>NIO即New IO,有两个特性:同步非阻塞,IO多路复用</p>
<p>AIO:异步IO,基于事件和回调机制实现,也就是应用操作之后会直接返回，不会堵塞在那里，<strong>当后台处理完成，操作系统会通知相应的线程进行后续的操作。</strong></p>
<p>如果不使用NIO,传统的方式是使用多线程,每个线程负责一个Socket,当并发量很大时,<strong>线程上下文切换的开销是很明显的</strong></p>
<p>NIO引入了IO多路复用,每个线程可以监听多个Socket,大大减少了线程上下文</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/xzwnp">云卷云舒</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ynu.icu/2023/03/18/juc/">https://ynu.icu/2023/03/18/juc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ynu.icu" target="_blank">云卷云舒</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="/img/img.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/18/mysql%E9%AB%98%E7%BA%A7%E7%AF%87%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96%E8%A1%A5%E5%85%85/"><img class="prev-cover" src="/img/img_2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2022/10/09/%E4%B8%8D%E8%A6%81%E5%86%8D%E4%BD%BF%E7%94%A8gitee%E5%BD%93md%E5%9B%BE%E5%BA%8A%E4%BA%86!/"><img class="next-cover" src="/img/img_4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">不要再使用gitee当图床了!</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/08/JVM/" title="JVM笔记"><img class="cover" src="/img/img_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-08</div><div class="title">JVM笔记</div></div></a></div><div><a href="/2023/03/18/SSM/%E4%B8%80%E3%80%81MyBatis/" title="Mybatis笔记"><img class="cover" src="/img/img.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-18</div><div class="title">Mybatis笔记</div></div></a></div><div><a href="/2023/03/18/SSM/%E4%BA%8C%E3%80%81Spring/" title="Spring笔记"><img class="cover" src="/img/img_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-18</div><div class="title">Spring笔记</div></div></a></div><div><a href="/2023/03/18/SSM/%E4%B8%89%E3%80%81SpringMVC/" title="SpringMVC笔记"><img class="cover" src="/img/img_5.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-18</div><div class="title">SpringMVC笔记</div></div></a></div><div><a href="/2023/03/19/%E6%9D%82%E8%B0%88/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" title="Spring如何解决循环依赖?为什么是三级缓存?"><img class="cover" src="/img/img_2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-19</div><div class="title">Spring如何解决循环依赖?为什么是三级缓存?</div></div></a></div><div><a href="/2023/03/18/Python%E7%AC%94%E8%AE%B0/" title="Python笔记"><img class="cover" src="/img/img_1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-18</div><div class="title">Python笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">云卷云舒</div><div class="author-info__description">你好,云友</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xzwnp"><i class="fab fa-github"></i><span>我的GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这家伙太懒了,连公告都没有留下</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-text">1.前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Synchronized"><span class="toc-text">1.1 Synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-wait%E4%B8%8Enotify"><span class="toc-text">1.1.2 wait与notify()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-3%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="toc-text">1.1.3虚假唤醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-lock%E5%92%8Csynchronized"><span class="toc-text">1.2 lock和synchronized</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.线程间通信(生产者消费者)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-text">3.集合类不安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E5%BC%95%E5%85%A5"><span class="toc-text">3.1引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-text">原因:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">解决方案:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2ConcurrentHashMap"><span class="toc-text">3.2ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">4.公平锁和非公平锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-callable%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">5.callable创建线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-JUC%E4%B8%89%E5%A4%A7%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-text">6.JUC三大辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch-%E5%87%8F%E5%B0%91%E8%AE%A1%E6%95%B0"><span class="toc-text">CountDownLatch: 减少计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%A2-CyclicBarrier-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F"><span class="toc-text">• CyclicBarrier: 循环栅栏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%A2-Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">• Semaphore: 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">7.读写锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-BlockingQueue"><span class="toc-text">8.BlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SynchronousQueue"><span class="toc-text">SynchronousQueue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">9.线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">1.使用Executors创建线程的三种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8ThreadPoolExecutor%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA-%E6%8E%A8%E8%8D%90"><span class="toc-text">2.使用ThreadPoolExecutor手动创建(推荐)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%A1%BA%E5%BA%8F"><span class="toc-text">3.线程池的工作顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">10.四大函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Function-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">1、Function 函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Predicate-%E6%B5%8B%E8%AF%95%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">2、Predicate 测试型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Consumer-%E6%B6%88%E8%B4%B9%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">3、Consumer 消费型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Supplier-%E4%BE%9B%E7%BB%99%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">4、Supplier 供给型接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">10.volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%91%EF%BC%89%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">１）保证可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJMM%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-text">1.1、什么是JMM模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E4%BB%A3%E7%A0%81%E9%AA%8C%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">1.2代码验证可见性:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%92%EF%BC%89%E4%B8%8D%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-text">２）不保证原子性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%93%EF%BC%89%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-text">３）禁止指令重排</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E3%80%81%E6%B7%B1%E5%85%A5%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">18、深入单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-text">1、饿汉式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">2、懒汉式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">3、静态内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%B8%87%E6%81%B6%E7%9A%84%E5%8F%8D%E5%B0%84"><span class="toc-text">4、万恶的反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%9E%9A%E4%B8%BE"><span class="toc-text">5、枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9F%A5%E7%9C%8B%E4%B8%8B%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-text">反编译查看下枚举的源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CAS"><span class="toc-text">19、深入理解CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81UnSafe"><span class="toc-text">1、UnSafe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8F%98%E9%87%8FvalueOffset"><span class="toc-text">2、变量valueOffset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%98%E9%87%8F-value%E7%94%A8volatile%E4%BF%AE%E9%A5%B0%EF%BC%8C%E4%BF%9D%E8%AF%81%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">3、变量 value用volatile修饰，保证了多线程之间的内存可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%EF%BC%88CompareAndSwap%EF%BC%89"><span class="toc-text">CAS（CompareAndSwap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E5%BA%94%E7%94%A8"><span class="toc-text">CAS 应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">CAS 的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20%E3%80%81%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-text">20、原子引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-text">ABA问题怎么产生的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%81%E8%A7%A3%E5%86%B3ABA%E9%97%AE%E9%A2%98%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E9%9C%80%E8%A6%81%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">要解决ABA问题，我们就需要加一个版本号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21%E3%80%81Java%E9%94%81"><span class="toc-text">21、Java锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%85%AC%E5%B9%B3%E9%94%81%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">1、公平锁非公平锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text">2、可重入锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BD%9C%E7%94%A8%E5%B0%B1%E6%98%AF%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-text">可重入锁最大的作用就是避免死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">3、自旋锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-text">4、死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E4%B8%BB%E8%A6%81%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-text">产生死锁主要原因：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95java%E8%87%AA%E5%B8%A6%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">拓展java自带工具操作：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-completableFuture"><span class="toc-text">22.completableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">1.基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">几个方法的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Then%E6%96%B9%E6%B3%95"><span class="toc-text">2.Then方法:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%BB%84"><span class="toc-text">第一组:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%BB%84"><span class="toc-text">第二组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunAfterBoth"><span class="toc-text">RunAfterBoth</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-text">23.同步,异步,阻塞,非阻塞</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/19/%E6%9D%82%E8%B0%88/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" title="Spring如何解决循环依赖?为什么是三级缓存?"><img src="/img/img_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring如何解决循环依赖?为什么是三级缓存?"/></a><div class="content"><a class="title" href="/2023/03/19/%E6%9D%82%E8%B0%88/Spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" title="Spring如何解决循环依赖?为什么是三级缓存?">Spring如何解决循环依赖?为什么是三级缓存?</a><time datetime="2023-03-19T08:12:56.870Z" title="发表于 2023-03-19 16:12:56">2023-03-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/18/SSM/%E4%B8%89%E3%80%81SpringMVC/" title="SpringMVC笔记"><img src="/img/img_5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringMVC笔记"/></a><div class="content"><a class="title" href="/2023/03/18/SSM/%E4%B8%89%E3%80%81SpringMVC/" title="SpringMVC笔记">SpringMVC笔记</a><time datetime="2023-03-18T11:40:45.460Z" title="发表于 2023-03-18 19:40:45">2023-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/18/SSM/%E4%BA%8C%E3%80%81Spring/" title="Spring笔记"><img src="/img/img_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring笔记"/></a><div class="content"><a class="title" href="/2023/03/18/SSM/%E4%BA%8C%E3%80%81Spring/" title="Spring笔记">Spring笔记</a><time datetime="2023-03-18T11:40:45.455Z" title="发表于 2023-03-18 19:40:45">2023-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/18/SSM/%E4%B8%80%E3%80%81MyBatis/" title="Mybatis笔记"><img src="/img/img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mybatis笔记"/></a><div class="content"><a class="title" href="/2023/03/18/SSM/%E4%B8%80%E3%80%81MyBatis/" title="Mybatis笔记">Mybatis笔记</a><time datetime="2023-03-18T11:40:45.450Z" title="发表于 2023-03-18 19:40:45">2023-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/18/Python%E7%AC%94%E8%AE%B0/" title="Python笔记"><img src="/img/img_1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python笔记"/></a><div class="content"><a class="title" href="/2023/03/18/Python%E7%AC%94%E8%AE%B0/" title="Python笔记">Python笔记</a><time datetime="2023-03-18T11:39:02.299Z" title="发表于 2023-03-18 19:39:02">2023-03-18</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(0, 0, 0, 0.15);"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 云卷云舒</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>互联网ICP备案:闽ICP备2022000871号-1</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>